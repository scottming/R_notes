[
["_main.html", "R notes while learning R 0.1 向量 0.2 矩阵 0.3 数据框 0.4 列表 0.5 特殊对象 0.6 数据读取与输出 0.7 向量化操作之 apply 家族 0.8 数据整理、转换 0.9 导入数据 0.10 数据筛选 filter，返回满足条件的观测值 0.11 子集选取 select，只保留选择的变量 0.12 数据排序 arrange 0.13 数据扩展 mutate 0.14 数据汇总 summarise 0.15 数据连接 join 0.16 分组汇总 group_by", " R notes while learning R Scott Ming 2016年7月30日 这里是明生学 R 的笔记。 0.1 向量 R 里面的向量看起来像 Python 的 list，但又不是 list，更像是Python 里一维的数组。 向量入门 基础 vec &lt;- c(1, 2, 3, 6, 5, 4) vec[c(1, 2, 4)] #&gt; [1] 1 2 6 class(vec) #&gt; [1] &quot;numeric&quot; vec[1:2] # 末尾包含 #&gt; [1] 1 2 Python 代码,除了用列表推导式之外还可以直接用 Numpy 实现 import numpy as np a= np.array([1, 2, 3, 6, 5, 4]) print(a[[0, 1, 3]]) print(type(a)) ## [1 2 6] ## &lt;class &#39;numpy.ndarray&#39;&gt; 创建向量 类 Python range a &lt;- seq(10) a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 b &lt;- seq(10, 13) b #&gt; [1] 10 11 12 13 temp &lt;- c(1, 2, 4, 0) temp * b #&gt; [1] 10 22 48 0 生成有规律的向量， 类 np.linspace vec &lt;- seq(1, 100, length.out = 10) # 还有个long参数也非常有用。 vec #&gt; [1] 1 12 23 34 45 56 67 78 89 100 vec[-4] #这点跟 Python 很不一样 #&gt; [1] 1 12 23 45 56 67 78 89 100 seq(from=2, to=1000, length.out = 10) #&gt; [1] 2.0000 112.8889 223.7778 334.6667 445.5556 556.4444 667.3333 #&gt; [8] 778.2222 889.1111 1000.0000 seq(from=2, to=1000, length=10) #&gt; [1] 2.0000 112.8889 223.7778 334.6667 445.5556 556.4444 667.3333 #&gt; [8] 778.2222 889.1111 1000.0000 group1 &lt;- rep(1:3, times = c(8, 10, 9)) group2 &lt;- factor(group1) # 转换成因子 group1 #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 class(group1) #&gt; [1] &quot;integer&quot; class(group2) #&gt; [1] &quot;factor&quot; length(group1) # as Py len #&gt; [1] 27 随机向量 vec_random1 &lt;- runif(5) # 0-1 vec_random1 #&gt; [1] 0.1301866 0.6891803 0.7843612 0.1212942 0.1194212 vec_random2 &lt;- sample(c(&#39;A&#39;, &#39;B&#39;), size = 10, replace = TRUE) # 随机字符向量 vec_random2 #&gt; [1] &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; vector1 &lt;- numeric(10) vector1 # empty vector #&gt; [1] 0 0 0 0 0 0 0 0 0 0 逻辑判断 temp[1:3] #&gt; [1] 1 2 4 temp[c(TRUE, TRUE, FALSE, FALSE)] #&gt; [1] 1 2 temp[temp &gt; 1] #&gt; [1] 2 4 0.2 矩阵 矩阵是二维的容器，可包含数值、逻辑、字符等数据 生成矩阵 vector &lt;- 1:12 class(vector) #&gt; [1] &quot;integer&quot; my_matrix &lt;- matrix(vector, nrow = 3, ncol = 4, byrow = FALSE) dim(my_matrix) #&gt; [1] 3 4 vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 my_matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 vector1 &lt;- vector2 &lt;- vector3 &lt;- runif(3) my_matrix &lt;- cbind(vector1, vector2, vector3) # 一致的向量类型进行合并 my_matrix #&gt; vector1 vector2 vector3 #&gt; [1,] 0.2892481 0.2892481 0.2892481 #&gt; [2,] 0.6438454 0.6438454 0.6438454 #&gt; [3,] 0.6423464 0.6423464 0.6423464 round(my_matrix*10, digits = 2) # 取2位 #&gt; vector1 vector2 vector3 #&gt; [1,] 2.89 2.89 2.89 #&gt; [2,] 6.44 6.44 6.44 #&gt; [3,] 6.42 6.42 6.42 取子集和计算 my_mat &lt;- matrix(c(8, 3, 4, 1, 5, 9, 6, 7, 2), ncol = 3) print(my_mat) #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 my_mat[1,1] + my_mat[1, 2] + my_mat[1,3] #&gt; [1] 15 sum(my_mat[1,]) #&gt; [1] 15 rowSums(my_mat) #&gt; [1] 15 15 15 colSums(my_mat) #&gt; [1] 15 15 15 sum(diag(my_mat)) #&gt; [1] 15 class(my_mat[1,]) # 退化成向量了 #&gt; [1] &quot;numeric&quot; my_mat[1, , drop=FALSE] # 保留矩阵属性 #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 my_mat[my_mat &lt;= 5] &lt;- 0 # 改变赋值 my_mat #&gt; [,1] [,2] [,3] #&gt; [1,] 8 0 6 #&gt; [2,] 0 0 7 #&gt; [3,] 0 9 0 # ifelse 函数 my_mat &lt;- matrix(c(8, 3, 4, 1, 5, 9, 6, 7, 2), ncol = 3) ifelse(my_mat &gt; 0.5, 1, 0) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 1 1 #&gt; [2,] 1 1 1 #&gt; [3,] 1 1 1 0.3 数据框 优点在于不同向量的数据类型可以不一样，但各列的长度必须一致 city &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;) temp &lt;- c(27, 29, 23, 14) data &lt;- data.frame(city, temp) # 对于 list，Py 不能直接这么导，会把整数向量变为索引，得用 dir 的方式 data #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 #&gt; 3 C 23 #&gt; 4 D 14 data[, 1] # Py data.ix[:,0] | data.iloc[:,0] #&gt; [1] A B C D #&gt; Levels: A B C D data$temp #&gt; [1] 27 29 23 14 class(data$city) # 本是字符，自动转了因子，若不想转，课用 stringAsFactors = FALSE 设定 #&gt; [1] &quot;factor&quot; 组合索引 data[data$temp &gt; mean(data$temp), ] #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 # data[&#39;temp&#39;, ] # empty，这是提取行的语法 data[, &#39;city&#39;] # 提取列 #&gt; [1] A B C D #&gt; Levels: A B C D data$temp &gt; mean(data$temp) #&gt; [1] TRUE TRUE FALSE FALSE with(data, data[temp &gt; mean(temp), ]) # 直接操作列名,省略 $ #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 with(data, data[temp &gt; mean(temp), &#39;city&#39;]) #&gt; [1] A B #&gt; Levels: A B C D 熟悉数据框最快的办法 summary(data) # as Py describe #&gt; city temp #&gt; A:1 Min. :14.00 #&gt; B:1 1st Qu.:20.75 #&gt; C:1 Median :25.00 #&gt; D:1 Mean :23.25 #&gt; 3rd Qu.:27.50 #&gt; Max. :29.00 dim(data) # as Py data.shape #&gt; [1] 4 2 head(data) # 看前6行 #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 #&gt; 3 C 23 #&gt; 4 D 14 #data.head(1) # 不能这么干 head(data, n = 1L) #&gt; city temp #&gt; 1 A 27 str(data) # 返回数据结构 #&gt; &#39;data.frame&#39;: 4 obs. of 2 variables: #&gt; $ city: Factor w/ 4 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;: 1 2 3 4 #&gt; $ temp: num 27 29 23 14 数据框的排序 order(data$temp) # 返回数据的索引号 #&gt; [1] 4 3 1 2 data[order(data$temp), ] #&gt; city temp #&gt; 4 D 14 #&gt; 3 C 23 #&gt; 1 A 27 #&gt; 2 B 29 data[order(data$temp, decreasing = T), ][1:2, ] # 反序 #&gt; city temp #&gt; 2 B 29 #&gt; 1 A 27 0.4 列表 data_list &lt;- list(temp = temp, city = city) print(data_list) #&gt; $temp #&gt; [1] 27 29 23 14 #&gt; #&gt; $city #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; data_list$mat &lt;- my_mat data_list$data &lt;- data names(data_list) #&gt; [1] &quot;temp&quot; &quot;city&quot; &quot;mat&quot; &quot;data&quot; class(data_list[3]) #&gt; [1] &quot;list&quot; data_list[3] #&gt; $mat #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 data_list[[3]] # 没有 name #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 class(data_list[[3]]) #&gt; [1] &quot;matrix&quot; 0.5 特殊对象 缺失值和空值 temp &lt;- c(27, 29, 23, 14, NA) mean(temp) #&gt; [1] NA mean(temp, na.rm = TRUE) #&gt; [1] 23.25 temp &lt;- c(27, 29, 23, 14, NULL) data_list &lt;- NULL # 快速删除一列 mean(temp) # TRUE #&gt; [1] 23.25 连接 textcon = textConnection(&#39;output&#39;, &#39;w&#39;) sink(textcon) # 开 x &lt;- runif(10) summary(x) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.04599 0.33850 0.50720 0.53870 0.81580 0.98520 print(&#39;这话不显示了，写入了 output 对象了&#39;) #&gt; [1] &quot;这话不显示了，写入了 output 对象了&quot; sink() # 关闭控制台转换 print(output) #&gt; character(0) showConnections() #&gt; description class mode text isopen can read can write #&gt; 4 &quot;output&quot; &quot;textConnection&quot; &quot;wr&quot; &quot;text&quot; &quot;opened&quot; &quot;no&quot; &quot;yes&quot; #&gt; 5 &quot;output&quot; &quot;textConnection&quot; &quot;w&quot; &quot;text&quot; &quot;opened&quot; &quot;no&quot; &quot;yes&quot; class(textcon) #&gt; [1] &quot;textConnection&quot; &quot;connection&quot; close(textcon) 公式 n &lt;- 1:50 xvar &lt;- paste0(&#39;x&#39;, n ) right &lt;- paste(xvar, collapse = &#39; + &#39;) left &lt;- &#39;y~&#39; my_formula &lt;- paste(left, right) my_formula &lt;- as.formula(my_formula) class(my_formula) #&gt; [1] &quot;formula&quot; left #&gt; [1] &quot;y~&quot; 表达式 ex &lt;- expression(x &lt;- seq(1, 10, 2)) print(ex) #&gt; expression(x &lt;- seq(1, 10, 2)) class(ex) #&gt; [1] &quot;expression&quot; eval(ex) print(x) #&gt; [1] 1 3 5 7 9 tex &lt;- c(&#39;z&lt;-seq(1, 10, 2)&#39;, &#39;print(z)&#39; ) eval(parse(text = tex)) #&gt; [1] 1 3 5 7 9 环境变量 ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;city&quot; &quot;data&quot; &quot;data_list&quot; #&gt; [6] &quot;ex&quot; &quot;group1&quot; &quot;group2&quot; &quot;left&quot; &quot;my_formula&quot; #&gt; [11] &quot;my_mat&quot; &quot;my_matrix&quot; &quot;n&quot; &quot;output&quot; &quot;right&quot; #&gt; [16] &quot;temp&quot; &quot;tex&quot; &quot;textcon&quot; &quot;vec&quot; &quot;vec_random1&quot; #&gt; [21] &quot;vec_random2&quot; &quot;vector&quot; &quot;vector1&quot; &quot;vector2&quot; &quot;vector3&quot; #&gt; [26] &quot;x&quot; &quot;xvar&quot; &quot;z&quot; env1 &lt;- new.env() assign(&quot;x1&quot;, 1:5, envir = env1) ls(envir = env1) #&gt; [1] &quot;x1&quot; get(&#39;x1&#39;, envir = env1) # 为啥没法直接用 x1 取呢？ #&gt; [1] 1 2 3 4 5 exists(&#39;x1&#39;, envir = env1) #&gt; [1] TRUE rm(&#39;x1&#39;, envir = env1) 函数 exp(1) #&gt; [1] 2.718282 myfunc &lt;- function(r){ area &lt;- pi*r^2 return(area) } # 内部可以调用 global value print(myfunc(4)) #&gt; [1] 50.26548 myfunc #&gt; function(r){ #&gt; area &lt;- pi*r^2 #&gt; return(area) #&gt; } 0.6 数据读取与输出 0.6.0.1 读取 read.table 读取普通数据可用 read.table，有6个参数比较重要： file：文件路径 sep：文件的分隔符，缺省无 skip：跳过开始的 skip 行开始读取 header：是否将第一行读取为列名，缺省 FALSE nrows：读取的行数 fill：将缺失数据定为 NA, 缺省并无指定 0.6.0.2 高阶包 readr 也可用 readr 包读取表格型数据，不仅速度快，且能直接读取为 tbl 格式。参考 readr 介绍。 library(readr) ## Warning: package &#39;readr&#39; was built under R version 3.3.1 read_csv 和 read_tsv 分别读取分隔符为逗号和制表符的数据，read_csv2 则是读取分号分割的数据，read_dlim 读取自定义的。 函数定义： read_delim(file, delim, quote = &quot;\\&quot;&quot;, escape_backslash = FALSE, escape_double = TRUE, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), comment = &quot;&quot;, skip = 0, n_max = -1, progress = interactive()) write_csv 用于写入数据，不写入行名。 函数定义 write_csv(x, path, na = &quot;NA&quot;, append = FALSE, col_names = !append) 0.7 向量化操作之 apply 家族 参考1：掌握R语言中的apply函数族 参考2：R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate 参考3：R语言apply家族函数的用法及其比较 0.7.0.1 循环迭代之 lapply/sapply sapply，lapply 的简化版 第一参数是 X，官方解释说，可接收向量，list，或表达式对象，其他对象将被强制按 list，第二个参数则是函数，返回一个向量或矩阵。 func &lt;- function(x){ if (x %% 2 == 0){ ret &lt;- &#39;even&#39; } else { ret &lt;- &#39;odd&#39; } return(ret) } vec &lt;- round(runif(4)*100) func(vec) #&gt; Warning in if (x%%2 == 0) {: the condition has length &gt; 1 and only the #&gt; first element will be used #&gt; [1] &quot;odd&quot; vec #&gt; [1] 59 8 5 23 sapply(vec, func) #&gt; [1] &quot;odd&quot; &quot;even&quot; &quot;odd&quot; &quot;odd&quot; lapply 跟 sapply 的区别在于返回的是列表 lapply(vec, func) #&gt; [[1]] #&gt; [1] &quot;odd&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;even&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;odd&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;odd&quot; mylist &lt;- as.list(iris[, 1:4]) # 不转list，也是强按 yourdata &lt;- iris[, 1:4] sapply(mylist, mean) # 还可以对列表进行计算 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.843333 3.057333 3.758000 1.199333 lapply(mylist, mean) # return a list #&gt; $Sepal.Length #&gt; [1] 5.843333 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.057333 #&gt; #&gt; $Petal.Length #&gt; [1] 3.758 #&gt; #&gt; $Petal.Width #&gt; [1] 1.199333 myfunc &lt;- function(x) { ret &lt;- c(mean(x),sd(x)) return(ret) } result &lt;- lapply(mylist, myfunc) result #&gt; $Sepal.Length #&gt; [1] 5.8433333 0.8280661 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.0573333 0.4358663 #&gt; #&gt; $Petal.Length #&gt; [1] 3.758000 1.765298 #&gt; #&gt; $Petal.Width #&gt; [1] 1.1993333 0.7622377 t(sapply(result, &#39;[&#39;)) # list数据转 data.frame #&gt; [,1] [,2] #&gt; Sepal.Length 5.843333 0.8280661 #&gt; Sepal.Width 3.057333 0.4358663 #&gt; Petal.Length 3.758000 1.7652982 #&gt; Petal.Width 1.199333 0.7622377 0.7.0.2 分组运算 apply 第一个参数接收数组或矩阵，MARGIN 参数按行或列计算 set.seed(1) vec &lt;- round(runif(12)*100) mat &lt;- matrix(vec, nrow = 3, ncol = 4) apply(mat, MARGIN = 1, sum) # 1为行，2为列 #&gt; [1] 218 144 228 tapply tapply用于分组的循环计算，通过INDEX参数可以把数据集X进行分组，相当于group by的操作。 head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa with(iris, tapply(Sepal.Length, list(Species), mean)) #&gt; setosa versicolor virginica #&gt; 5.006 5.936 6.588 aggregate 比较友好，返回的是数据框 aggregate(iris$Sepal.Length, list(iris$Species), mean) #&gt; Group.1 x #&gt; 1 setosa 5.006 #&gt; 2 versicolor 5.936 #&gt; 3 virginica 6.588 0.7.0.3 多参数运算 mapply 这个函数目前理解的还不是很透彻，待补。 mapply(rep, times = 1:4, x = 4:1) #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] 3 3 #&gt; #&gt; [[3]] #&gt; [1] 2 2 2 #&gt; #&gt; [[4]] #&gt; [1] 1 1 1 1 0.8 数据整理、转换 0.8.0.1 reshape2 subdata &lt;-iris[,4:5] head(subdata) #&gt; Petal.Width Species #&gt; 1 0.2 setosa #&gt; 2 0.2 setosa #&gt; 3 0.2 setosa #&gt; 4 0.2 setosa #&gt; 5 0.2 setosa #&gt; 6 0.4 setosa data_w &lt;- unstack(subdata) colMeans(data_w) #&gt; setosa versicolor virginica #&gt; 0.246 1.326 2.026 实践中这种单纯的长宽格式并不多见，更常见的是直接一步得到结果，所以就需要强大的 reshape2 包 参考An Introduction to reshape2 加载包和改数据名 library(reshape2) names(airquality) &lt;- tolower(names(airquality)) head(airquality) #&gt; ozone solar.r wind temp month day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 melt 熔化转长格式 aql &lt;- melt(airquality) #&gt; No id variables; using all as measure variables tail(aql) #&gt; variable value #&gt; 913 day 25 #&gt; 914 day 26 #&gt; 915 day 27 #&gt; 916 day 28 #&gt; 917 day 29 #&gt; 918 day 30 head(aql) #&gt; variable value #&gt; 1 ozone 41 #&gt; 2 ozone 36 #&gt; 3 ozone 12 #&gt; 4 ozone 18 #&gt; 5 ozone NA #&gt; 6 ozone 28 设定不需要变 value 的变量 aql &lt;- melt(airquality,id.vars = c(&#39;month&#39;, &#39;day&#39;)) names(airquality) #&gt; [1] &quot;ozone&quot; &quot;solar.r&quot; &quot;wind&quot; &quot;temp&quot; &quot;month&quot; &quot;day&quot; head(aql) #&gt; month day variable value #&gt; 1 5 1 ozone 41 #&gt; 2 5 2 ozone 36 #&gt; 3 5 3 ozone 12 #&gt; 4 5 4 ozone 18 #&gt; 5 5 5 ozone NA #&gt; 6 5 6 ozone 28 改名 aql &lt;- melt(airquality, id.vars = c(&quot;month&quot;, &quot;day&quot;), variable.name = &quot;climate_variable&quot;, value.name = &quot;climate_value&quot;) head(aql) #&gt; month day climate_variable climate_value #&gt; 1 5 1 ozone 41 #&gt; 2 5 2 ozone 36 #&gt; 3 5 3 ozone 12 #&gt; 4 5 4 ozone 18 #&gt; 5 5 5 ozone NA #&gt; 6 5 6 ozone 28 head(airquality) #&gt; ozone solar.r wind temp month day #&gt; 1 41 190 7.4 67 5 1 #&gt; 2 36 118 8.0 72 5 2 #&gt; 3 12 149 12.6 74 5 3 #&gt; 4 18 313 11.5 62 5 4 #&gt; 5 NA NA 14.3 56 5 5 #&gt; 6 28 NA 14.9 66 5 6 dcast 重铸，长转宽 aql &lt;- melt(airquality, id.vars = c(&quot;month&quot;, &quot;day&quot;)) aqw &lt;- dcast(aql, month + day ~ variable) head(aql) #&gt; month day variable value #&gt; 1 5 1 ozone 41 #&gt; 2 5 2 ozone 36 #&gt; 3 5 3 ozone 12 #&gt; 4 5 4 ozone 18 #&gt; 5 5 5 ozone NA #&gt; 6 5 6 ozone 28 head(aqw) #&gt; month day ozone solar.r wind temp #&gt; 1 5 1 41 190 7.4 67 #&gt; 2 5 2 36 118 8.0 72 #&gt; 3 5 3 12 149 12.6 74 #&gt; 4 5 4 18 313 11.5 62 #&gt; 5 5 5 NA NA 14.3 56 #&gt; 6 5 6 28 NA 14.9 66 不足的id.var 会出错，会把值的数量统计出来 dcast(aql, month ~ variable) #&gt; Aggregation function missing: defaulting to length #&gt; month ozone solar.r wind temp #&gt; 1 5 31 31 31 31 #&gt; 2 6 30 30 30 30 #&gt; 3 7 31 31 31 31 #&gt; 4 8 31 31 31 31 #&gt; 5 9 30 30 30 30 fun,加上集合函数就能按正确方式集合了。 dcast(aql, month ~ variable, fun.aggregate = mean, na.rm = TRUE) #&gt; month ozone solar.r wind temp #&gt; 1 5 23.61538 181.2963 11.622581 65.54839 #&gt; 2 6 29.44444 190.1667 10.266667 79.10000 #&gt; 3 7 59.11538 216.4839 8.941935 83.90323 #&gt; 4 8 59.96154 171.8571 8.793548 83.96774 #&gt; 5 9 31.44828 167.4333 10.180000 76.90000 0.8.0.2 tidyr 新建一列数据 mtcars$car &lt;- rownames(mtcars) colnames(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; &quot;car&quot; mtcars &lt;- mtcars[, c(12, 1:11)] head(mtcars) #&gt; car mpg cyl disp hp drat wt qsec vs #&gt; Mazda RX4 Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 #&gt; Mazda RX4 Wag Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 #&gt; Datsun 710 Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 #&gt; Hornet 4 Drive Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 #&gt; Hornet Sportabout Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 #&gt; Valiant Valiant 18.1 6 225 105 2.76 3.460 20.22 1 #&gt; am gear carb #&gt; Mazda RX4 1 4 4 #&gt; Mazda RX4 Wag 1 4 4 #&gt; Datsun 710 1 4 1 #&gt; Hornet 4 Drive 0 3 1 #&gt; Hornet Sportabout 0 3 2 #&gt; Valiant 0 3 1 gather 聚合 library(tidyr) #&gt; Warning: package &#39;tidyr&#39; was built under R version 3.3.1 #&gt; #&gt; Attaching package: &#39;tidyr&#39; #&gt; The following object is masked from &#39;package:reshape2&#39;: #&gt; #&gt; smiths mtcarsNew &lt;- mtcars %&gt;% gather(attribute, value, -car) #不仅聚合，且命名了。 head(mtcarsNew) #&gt; car attribute value #&gt; 1 Mazda RX4 mpg 21.0 #&gt; 2 Mazda RX4 Wag mpg 21.0 #&gt; 3 Datsun 710 mpg 22.8 #&gt; 4 Hornet 4 Drive mpg 21.4 #&gt; 5 Hornet Sportabout mpg 18.7 #&gt; 6 Valiant mpg 18.1 tail(mtcarsNew) #&gt; car attribute value #&gt; 347 Porsche 914-2 carb 2 #&gt; 348 Lotus Europa carb 2 #&gt; 349 Ford Pantera L carb 4 #&gt; 350 Ferrari Dino carb 6 #&gt; 351 Maserati Bora carb 8 #&gt; 352 Volvo 142E carb 2 gather mpg:gear 之间的列 mtcarsNew &lt;- mtcars %&gt;% gather(attribute, value, mpg:gear) spread 铺开 mtcarsWide &lt;- mtcarsNew %&gt;% spread(attribute, value) head(mtcarsWide) #&gt; car carb am cyl disp drat gear hp mpg qsec vs wt #&gt; 1 AMC Javelin 2 0 8 304 3.15 3 150 15.2 17.30 0 3.435 #&gt; 2 Cadillac Fleetwood 4 0 8 472 2.93 3 205 10.4 17.98 0 5.250 #&gt; 3 Camaro Z28 4 0 8 350 3.73 3 245 13.3 15.41 0 3.840 #&gt; 4 Chrysler Imperial 4 0 8 440 3.23 3 230 14.7 17.42 0 5.345 #&gt; 5 Datsun 710 1 1 4 108 3.85 4 93 22.8 18.61 1 2.320 #&gt; 6 Dodge Challenger 2 0 8 318 2.76 3 150 15.5 16.87 0 3.520 unite 合并 set.seed(1) date &lt;- as.Date(&#39;2016-06-01&#39;) + 0:14 hour &lt;- sample(1:24, 15) min &lt;- sample(1:60, 15) second &lt;- sample(1:60, 15) event &lt;- sample(letters, 15) df &lt;- data.frame(date, hour, min, second, event) head(df) #&gt; date hour min second event #&gt; 1 2016-06-01 7 30 29 u #&gt; 2 2016-06-02 9 43 36 a #&gt; 3 2016-06-03 13 58 60 l #&gt; 4 2016-06-04 20 22 11 q #&gt; 5 2016-06-05 5 44 47 p #&gt; 6 2016-06-06 18 52 37 k df1 &lt;- df %&gt;% unite(datehour, date, hour, sep = &#39; &#39;) %&gt;% unite(datetime, datehour, min, second, sep = &#39;:&#39;) df1 #&gt; datetime event #&gt; 1 2016-06-01 7:30:29 u #&gt; 2 2016-06-02 9:43:36 a #&gt; 3 2016-06-03 13:58:60 l #&gt; 4 2016-06-04 20:22:11 q #&gt; 5 2016-06-05 5:44:47 p #&gt; 6 2016-06-06 18:52:37 k #&gt; 7 2016-06-07 19:12:43 r #&gt; 8 2016-06-08 12:35:6 i #&gt; 9 2016-06-09 11:7:38 e #&gt; 10 2016-06-10 1:14:21 b #&gt; 11 2016-06-11 3:20:42 w #&gt; 12 2016-06-12 14:1:32 t #&gt; 13 2016-06-13 23:19:52 h #&gt; 14 2016-06-14 21:41:26 s #&gt; 15 2016-06-15 8:16:25 o separate 拆分 df2 &lt;- df1 %&gt;% separate(datetime, c(&#39;date&#39;, &#39;time&#39;), sep = &#39; &#39;) %&gt;% separate(time, c(&#39;hour&#39;, &#39;min&#39;, &#39;second&#39;), sep = &#39;:&#39;) df2 #&gt; date hour min second event #&gt; 1 2016-06-01 7 30 29 u #&gt; 2 2016-06-02 9 43 36 a #&gt; 3 2016-06-03 13 58 60 l #&gt; 4 2016-06-04 20 22 11 q #&gt; 5 2016-06-05 5 44 47 p #&gt; 6 2016-06-06 18 52 37 k #&gt; 7 2016-06-07 19 12 43 r #&gt; 8 2016-06-08 12 35 6 i #&gt; 9 2016-06-09 11 7 38 e #&gt; 10 2016-06-10 1 14 21 b #&gt; 11 2016-06-11 3 20 42 w #&gt; 12 2016-06-12 14 1 32 t #&gt; 13 2016-06-13 23 19 52 h #&gt; 14 2016-06-14 21 41 26 s #&gt; 15 2016-06-15 8 16 25 o 总的来说，tidyr 包比reshape语法更为简洁易懂， 更加方便。 0.9 导入数据 # 用 readr 包把数据读取成 tbl 格式，省去转化的那一步。 library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(readr) order &lt;- read_csv(&#39;D://Nutstore/R/dplyr/dplyr-data/order.csv&#39;)[-1] # 去除空名的第一列 order #&gt; Source: local data frame [100,000 x 11] #&gt; #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; (int) (int) (int) (date) (chr) (chr) (chr) #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002856 103122 2141 2011-06-02 MIAMI FL 33137 #&gt; 4 1002857 130980 2173 2009-10-14 E RUTHERFORD NJ 07073 #&gt; 5 1002886 48553 2141 2010-11-19 BALTIMORE MD 21218 #&gt; 6 1002887 106150 2173 2009-10-15 ROWAYTON CT 06853 #&gt; 7 1002888 27805 2173 2009-10-15 INDIANAPOLIS IN 46240 #&gt; 8 1002889 24546 2173 2009-10-15 PLEASANTVILLE NY 10570 #&gt; 9 1002890 43783 2173 2009-10-15 EAST STROUDSBURG PA 18301 #&gt; 10 1003004 15688 2173 2009-10-15 ROUND LAKE PARK IL 60073 #&gt; .. ... ... ... ... ... ... ... #&gt; Variables not shown: paymenttype (chr), totalprice (dbl), numorderlines #&gt; (int), numunits (int) 0.10 数据筛选 filter，返回满足条件的观测值 # 看 2009-10-15 日的数据 filter(order, orderdate == &#39;2009-10-13&#39;) #&gt; Source: local data frame [19 x 11] #&gt; #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; (int) (int) (int) (date) (chr) (chr) (chr) #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002442 112970 2173 2009-10-13 BRANFORD CT 06405 #&gt; 4 1002471 125377 2173 2009-10-13 VALLEY FORGE PA 19482 #&gt; 5 1002472 133164 2173 2009-10-13 FORT WORTH TX 76107 #&gt; 6 1003224 129708 2173 2009-10-13 CERRO GORDO NC 28430 #&gt; 7 1003372 164007 2141 2009-10-13 LOUISVILLE KY 40205 #&gt; 8 1003373 44085 2141 2009-10-13 CORAL GABLES FL 33146 #&gt; 9 1003374 106995 2173 2009-10-13 BETHLEHEM PA 18018 #&gt; 10 1003375 103991 2173 2009-10-13 WANTAGH NY 11793 #&gt; 11 1003376 129752 2173 2009-10-13 LEWISBURG PA 17837 #&gt; 12 1003377 46294 2173 2009-10-13 NEW YORK NY 10128 #&gt; 13 1001597 49948 2173 2009-10-13 PISCATAWAY NJ 08854 #&gt; 14 1002337 152447 2173 2009-10-13 BROOKLYN NY 11238 #&gt; 15 1002338 7990 2173 2009-10-13 BROOKLYN NY 11238 #&gt; 16 1002367 6986 2173 2009-10-13 RICHWOOD NJ 07450 #&gt; 17 1002368 103129 2204 2009-10-13 WHITEHALL PA 18052 #&gt; 18 1002619 93175 2173 2009-10-13 BASKING RIDGE NJ 07920 #&gt; 19 1002853 106161 2173 2009-10-13 BROOKSIDE NJ 07926 #&gt; Variables not shown: paymenttype (chr), totalprice (dbl), numorderlines #&gt; (int), numunits (int) # 更细的筛选 filter(order, orderdate == &#39;2009-10-13&#39; &amp; totalprice &gt; 100) -&gt; new_tbl new_tbl #&gt; Source: local data frame [1 x 11] #&gt; #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; (int) (int) (int) (date) (chr) (chr) (chr) #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; Variables not shown: paymenttype (chr), totalprice (dbl), numorderlines #&gt; (int), numunits (int) 0.11 子集选取 select，只保留选择的变量 # 选取几个子集 names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; select(order, city, numunits, zipcode) #&gt; Source: local data frame [100,000 x 3] #&gt; #&gt; city numunits zipcode #&gt; (chr) (int) (chr) #&gt; 1 NEWTON 3 02459 #&gt; 2 NEW ROCHELLE 1 10804 #&gt; 3 MIAMI 2 33137 #&gt; 4 E RUTHERFORD 1 07073 #&gt; 5 BALTIMORE 1 21218 #&gt; 6 ROWAYTON 1 06853 #&gt; 7 INDIANAPOLIS 1 46240 #&gt; 8 PLEASANTVILLE 1 10570 #&gt; 9 EAST STROUDSBURG 2 18301 #&gt; 10 ROUND LAKE PARK 1 60073 #&gt; .. ... ... ... # 换名, 提取选择的数据列 select(order, date = orderdate, price = totalprice) #&gt; Source: local data frame [100,000 x 2] #&gt; #&gt; date price #&gt; (date) (dbl) #&gt; 1 2009-10-13 190.00 #&gt; 2 2009-10-13 10.00 #&gt; 3 2011-06-02 35.22 #&gt; 4 2009-10-14 10.00 #&gt; 5 2010-11-19 10.00 #&gt; 6 2009-10-15 10.00 #&gt; 7 2009-10-15 10.00 #&gt; 8 2009-10-15 10.00 #&gt; 9 2009-10-15 29.68 #&gt; 10 2009-10-15 19.68 #&gt; .. ... ... names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; # rename,换名，提取所有列 rename(order, date = orderdate, price = totalprice) #&gt; Source: local data frame [100,000 x 11] #&gt; #&gt; orderid customerid campaignid date city state zipcode #&gt; (int) (int) (int) (date) (chr) (chr) (chr) #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002856 103122 2141 2011-06-02 MIAMI FL 33137 #&gt; 4 1002857 130980 2173 2009-10-14 E RUTHERFORD NJ 07073 #&gt; 5 1002886 48553 2141 2010-11-19 BALTIMORE MD 21218 #&gt; 6 1002887 106150 2173 2009-10-15 ROWAYTON CT 06853 #&gt; 7 1002888 27805 2173 2009-10-15 INDIANAPOLIS IN 46240 #&gt; 8 1002889 24546 2173 2009-10-15 PLEASANTVILLE NY 10570 #&gt; 9 1002890 43783 2173 2009-10-15 EAST STROUDSBURG PA 18301 #&gt; 10 1003004 15688 2173 2009-10-15 ROUND LAKE PARK IL 60073 #&gt; .. ... ... ... ... ... ... ... #&gt; Variables not shown: paymenttype (chr), price (dbl), numorderlines (int), #&gt; numunits (int) names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; # 选取以 order 开始的变量 select(order, starts_with(&#39;order&#39;)) #&gt; Source: local data frame [100,000 x 2] #&gt; #&gt; orderid orderdate #&gt; (int) (date) #&gt; 1 1002854 2009-10-13 #&gt; 2 1002855 2009-10-13 #&gt; 3 1002856 2011-06-02 #&gt; 4 1002857 2009-10-14 #&gt; 5 1002886 2010-11-19 #&gt; 6 1002887 2009-10-15 #&gt; 7 1002888 2009-10-15 #&gt; 8 1002889 2009-10-15 #&gt; 9 1002890 2009-10-15 #&gt; 10 1003004 2009-10-15 #&gt; .. ... ... # 选取包含id 的变量 select(order, contains(&#39;id&#39;)) #&gt; Source: local data frame [100,000 x 3] #&gt; #&gt; orderid customerid campaignid #&gt; (int) (int) (int) #&gt; 1 1002854 45978 2141 #&gt; 2 1002855 125381 2173 #&gt; 3 1002856 103122 2141 #&gt; 4 1002857 130980 2173 #&gt; 5 1002886 48553 2141 #&gt; 6 1002887 106150 2173 #&gt; 7 1002888 27805 2173 #&gt; 8 1002889 24546 2173 #&gt; 9 1002890 43783 2173 #&gt; 10 1003004 15688 2173 #&gt; .. ... ... ... 0.12 数据排序 arrange tbl &lt;- select(order, date = orderdate, price = totalprice) arrange(tbl, date, desc(price)) #&gt; Source: local data frame [100,000 x 2] #&gt; #&gt; date price #&gt; (date) (dbl) #&gt; 1 2009-10-04 200 #&gt; 2 2009-10-04 120 #&gt; 3 2009-10-04 100 #&gt; 4 2009-10-04 100 #&gt; 5 2009-10-04 70 #&gt; 6 2009-10-04 50 #&gt; 7 2009-10-04 50 #&gt; 8 2009-10-04 40 #&gt; 9 2009-10-04 40 #&gt; 10 2009-10-04 40 #&gt; .. ... ... # 管道操作，更简便 tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% arrange(date, desc(price)) tbl #&gt; Source: local data frame [100,000 x 2] #&gt; #&gt; date price #&gt; (date) (dbl) #&gt; 1 2009-10-04 200 #&gt; 2 2009-10-04 120 #&gt; 3 2009-10-04 100 #&gt; 4 2009-10-04 100 #&gt; 5 2009-10-04 70 #&gt; 6 2009-10-04 50 #&gt; 7 2009-10-04 50 #&gt; 8 2009-10-04 40 #&gt; 9 2009-10-04 40 #&gt; 10 2009-10-04 40 #&gt; .. ... ... 0.13 数据扩展 mutate tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% arrange(date,desc(price)) %&gt;% mutate(year = substr(date,1,4), month = substr(date,6,7), day = substr(date,9,10)) tbl #&gt; Source: local data frame [100,000 x 5] #&gt; #&gt; date price year month day #&gt; (date) (dbl) (chr) (chr) (chr) #&gt; 1 2009-10-04 200 2009 10 04 #&gt; 2 2009-10-04 120 2009 10 04 #&gt; 3 2009-10-04 100 2009 10 04 #&gt; 4 2009-10-04 100 2009 10 04 #&gt; 5 2009-10-04 70 2009 10 04 #&gt; 6 2009-10-04 50 2009 10 04 #&gt; 7 2009-10-04 50 2009 10 04 #&gt; 8 2009-10-04 40 2009 10 04 #&gt; 9 2009-10-04 40 2009 10 04 #&gt; 10 2009-10-04 40 2009 10 04 #&gt; .. ... ... ... ... ... # transmute 则会删除原有的变量，如同 select 与 rename 0.14 数据汇总 summarise summarise(tbl, max = max(price), min = min(price), mean(price)) #&gt; Source: local data frame [1 x 3] #&gt; #&gt; max min mean(price) #&gt; (dbl) (dbl) (dbl) #&gt; 1 6780 0 60.77773 summarise(tbl, fisrt = first(date), last = last(date)) #&gt; Source: local data frame [1 x 2] #&gt; #&gt; fisrt last #&gt; (date) (date) #&gt; 1 2009-10-04 2014-05-29 # 管道操作 df &lt;- select(order, date = orderdate, price = totalprice) %&gt;% summarise(price_sum = sum(price), price_mean = mean(price)) df #&gt; Source: local data frame [1 x 2] #&gt; #&gt; price_sum price_mean #&gt; (dbl) (dbl) #&gt; 1 6077773 60.77773 0.15 数据连接 join left_join 以左边为主，且保留所有值，用的最多，b 表追加在后面 inner_join 只保留匹配的 semi_join 只匹配左边的列 anti_join 与上面函数相反 0.16 分组汇总 group_by tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% mutate(year = substr(date,1,4), month = substr(date,6,7), day = substr(date,9,10)) by_year &lt;- group_by(tbl, year) %&gt;% summarise(mean(price), sum(price), max(month)) by_year #&gt; Source: local data frame [6 x 4] #&gt; #&gt; year mean(price) sum(price) max(month) #&gt; (chr) (dbl) (dbl) (chr) #&gt; 1 2009 34.13850 262627.5 12 #&gt; 2 2010 52.23982 967429.2 12 #&gt; 3 2011 51.35342 1380636.6 12 #&gt; 4 2012 68.40990 1404113.1 12 #&gt; 5 2013 76.71011 1633004.8 12 #&gt; 6 2014 84.47190 429962.0 05 order_year &lt;- group_by(tbl, year) "]
]
