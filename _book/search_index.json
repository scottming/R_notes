[
["r-.html", "学 R 笔记 1 R 数据结构 1.1 向量 1.2 矩阵 1.3 数据框 1.4 列表 1.5 特殊对象", " 学 R 笔记 Scott Ming 2016-07-30 1 R 数据结构 1.1 向量 R 里面的向量看起来像 Python 的 list，但又不是 list，更像是Python 里一维的数组。 向量入门 基础 vec &lt;- c(1, 2, 3, 6, 5, 4) vec[c(1, 2, 4)] #&gt; [1] 1 2 6 class(vec) #&gt; [1] &quot;numeric&quot; vec[1:2] # 末尾包含 #&gt; [1] 1 2 Python 代码,除了用列表推导式之外还可以直接用 Numpy 实现 import numpy as np a= np.array([1, 2, 3, 6, 5, 4]) print a[[0, 1, 3]] print type(a) #&gt; [1 2 6] #&gt; &lt;type &#39;numpy.ndarray&#39;&gt; 创建向量 类 Python range a &lt;- seq(10) a #&gt; [1] 1 2 3 4 5 6 7 8 9 10 b &lt;- seq(10, 13) b #&gt; [1] 10 11 12 13 temp &lt;- c(1, 2, 4, 0) temp * b #&gt; [1] 10 22 48 0 生成有规律的向量， 类 np.linspace vec &lt;- seq(1, 100, length.out = 10) # 还有个long参数也非常有用。 vec #&gt; [1] 1 12 23 34 45 56 67 78 89 100 vec[-4] #这点跟 Python 很不一样 #&gt; [1] 1 12 23 45 56 67 78 89 100 seq(from=2, to=1000, length.out = 10) #&gt; [1] 2 113 224 335 446 556 667 778 889 1000 seq(from=2, to=1000, length=10) #&gt; [1] 2 113 224 335 446 556 667 778 889 1000 group1 &lt;- rep(1:3, times = c(8, 10, 9)) group2 &lt;- factor(group1) # 转换成因子 group1 #&gt; [1] 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 class(group1) #&gt; [1] &quot;integer&quot; class(group2) #&gt; [1] &quot;factor&quot; length(group1) # as Py len #&gt; [1] 27 随机向量 vec_random1 &lt;- runif(5) # 0-1 vec_random1 #&gt; [1] 0.0808 0.8343 0.6008 0.1572 0.0074 vec_random2 &lt;- sample(c(&#39;A&#39;, &#39;B&#39;), size = 10, replace = TRUE) # 随机字符向量 vec_random2 #&gt; [1] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; vector1 &lt;- numeric(10) vector1 # empty vector #&gt; [1] 0 0 0 0 0 0 0 0 0 0 逻辑判断 temp[1:3] #&gt; [1] 1 2 4 temp[c(TRUE, TRUE, FALSE, FALSE)] #&gt; [1] 1 2 temp[temp &gt; 1] #&gt; [1] 2 4 1.2 矩阵 矩阵是二维的容器，可包含数值、逻辑、字符等数据 生成矩阵 vector &lt;- 1:12 class(vector) #&gt; [1] &quot;integer&quot; my_matrix &lt;- matrix(vector, nrow = 3, ncol = 4, byrow = FALSE) dim(my_matrix) #&gt; [1] 3 4 vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 my_matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 vector1 &lt;- vector2 &lt;- vector3 &lt;- runif(3) my_matrix &lt;- cbind(vector1, vector2, vector3) # 一致的向量类型进行合并 my_matrix #&gt; vector1 vector2 vector3 #&gt; [1,] 0.1957 0.1957 0.1957 #&gt; [2,] 0.4035 0.4035 0.4035 #&gt; [3,] 0.0637 0.0637 0.0637 round(my_matrix*10, digits = 2) # 取2位 #&gt; vector1 vector2 vector3 #&gt; [1,] 1.96 1.96 1.96 #&gt; [2,] 4.04 4.04 4.04 #&gt; [3,] 0.64 0.64 0.64 取子集和计算 my_mat &lt;- matrix(c(8, 3, 4, 1, 5, 9, 6, 7, 2), ncol = 3) print(my_mat) #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 my_mat[1,1] + my_mat[1, 2] + my_mat[1,3] #&gt; [1] 15 sum(my_mat[1,]) #&gt; [1] 15 rowSums(my_mat) #&gt; [1] 15 15 15 colSums(my_mat) #&gt; [1] 15 15 15 sum(diag(my_mat)) #&gt; [1] 15 class(my_mat[1,]) # 退化成向量了 #&gt; [1] &quot;numeric&quot; my_mat[1, , drop=FALSE] # 保留矩阵属性 #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 my_mat[my_mat &lt;= 5] &lt;- 0 # 改变赋值 my_mat #&gt; [,1] [,2] [,3] #&gt; [1,] 8 0 6 #&gt; [2,] 0 0 7 #&gt; [3,] 0 9 0 # ifelse 函数 my_mat &lt;- matrix(c(8, 3, 4, 1, 5, 9, 6, 7, 2), ncol = 3) ifelse(my_mat &gt; 0.5, 1, 0) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 1 1 #&gt; [2,] 1 1 1 #&gt; [3,] 1 1 1 1.3 数据框 优点在于不同向量的数据类型可以不一样，但各列的长度必须一致 city &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;) temp &lt;- c(27, 29, 23, 14) data &lt;- data.frame(city, temp) # 对于 list，Py 不能直接这么导，会把整数向量变为索引，得用 dir 的方式 data #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 #&gt; 3 C 23 #&gt; 4 D 14 data[, 1] # Py data.ix[:,0] | data.iloc[:,0] #&gt; [1] A B C D #&gt; Levels: A B C D data$temp #&gt; [1] 27 29 23 14 class(data$city) # 本是字符，自动转了因子，若不想转，课用 stringAsFactors = FALSE 设定 #&gt; [1] &quot;factor&quot; 组合索引 data[data$temp &gt; mean(data$temp), ] #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 # data[&#39;temp&#39;, ] # empty，这是提取行的语法 data[, &#39;city&#39;] # 提取列 #&gt; [1] A B C D #&gt; Levels: A B C D data$temp &gt; mean(data$temp) #&gt; [1] TRUE TRUE FALSE FALSE with(data, data[temp &gt; mean(temp), ]) # 直接操作列名,省略 $ #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 with(data, data[temp &gt; mean(temp), &#39;city&#39;]) #&gt; [1] A B #&gt; Levels: A B C D 熟悉数据框最快的办法 summary(data) # as Py describe #&gt; city temp #&gt; A:1 Min. :14.0 #&gt; B:1 1st Qu.:20.8 #&gt; C:1 Median :25.0 #&gt; D:1 Mean :23.2 #&gt; 3rd Qu.:27.5 #&gt; Max. :29.0 dim(data) # as Py data.shape #&gt; [1] 4 2 head(data) # 看前6行 #&gt; city temp #&gt; 1 A 27 #&gt; 2 B 29 #&gt; 3 C 23 #&gt; 4 D 14 #data.head(1) # 不能这么干 head(data, n = 1L) #&gt; city temp #&gt; 1 A 27 str(data) # 返回数据结构 #&gt; &#39;data.frame&#39;: 4 obs. of 2 variables: #&gt; $ city: Factor w/ 4 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;: 1 2 3 4 #&gt; $ temp: num 27 29 23 14 数据框的排序 order(data$temp) # 返回数据的索引号 #&gt; [1] 4 3 1 2 data[order(data$temp), ] #&gt; city temp #&gt; 4 D 14 #&gt; 3 C 23 #&gt; 1 A 27 #&gt; 2 B 29 data[order(data$temp, decreasing = T), ][1:2, ] # 反序 #&gt; city temp #&gt; 2 B 29 #&gt; 1 A 27 1.4 列表 data_list &lt;- list(temp = temp, city = city) print(data_list) #&gt; $temp #&gt; [1] 27 29 23 14 #&gt; #&gt; $city #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; data_list$mat &lt;- my_mat data_list$data &lt;- data names(data_list) #&gt; [1] &quot;temp&quot; &quot;city&quot; &quot;mat&quot; &quot;data&quot; class(data_list[3]) #&gt; [1] &quot;list&quot; data_list[3] #&gt; $mat #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 data_list[[3]] # 没有 name #&gt; [,1] [,2] [,3] #&gt; [1,] 8 1 6 #&gt; [2,] 3 5 7 #&gt; [3,] 4 9 2 class(data_list[[3]]) #&gt; [1] &quot;matrix&quot; 1.5 特殊对象 缺失值和空值 temp &lt;- c(27, 29, 23, 14, NA) mean(temp) #&gt; [1] NA mean(temp, na.rm = TRUE) #&gt; [1] 23.2 temp &lt;- c(27, 29, 23, 14, NULL) data_list &lt;- NULL # 快速删除一列 mean(temp) # TRUE #&gt; [1] 23.2 连接 textcon = textConnection(&#39;output&#39;, &#39;w&#39;) sink(textcon) # 开 x &lt;- runif(10) summary(x) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.051 0.315 0.604 0.557 0.740 0.981 print(&#39;这话不显示了，写入了 output 对象了&#39;) #&gt; [1] &quot;这话不显示了，写入了 output 对象了&quot; sink() # 关闭控制台转换 print(output) #&gt; character(0) showConnections() #&gt; description class mode text isopen can read can write #&gt; 4 &quot;output&quot; &quot;textConnection&quot; &quot;wr&quot; &quot;text&quot; &quot;opened&quot; &quot;no&quot; &quot;yes&quot; #&gt; 5 &quot;output&quot; &quot;textConnection&quot; &quot;w&quot; &quot;text&quot; &quot;opened&quot; &quot;no&quot; &quot;yes&quot; class(textcon) #&gt; [1] &quot;textConnection&quot; &quot;connection&quot; close(textcon) 公式 n &lt;- 1:50 xvar &lt;- paste0(&#39;x&#39;, n ) right &lt;- paste(xvar, collapse = &#39; + &#39;) left &lt;- &#39;y~&#39; my_formula &lt;- paste(left, right) my_formula &lt;- as.formula(my_formula) class(my_formula) #&gt; [1] &quot;formula&quot; left #&gt; [1] &quot;y~&quot; 表达式 ex &lt;- expression(x &lt;- seq(1, 10, 2)) print(ex) #&gt; expression(x &lt;- seq(1, 10, 2)) class(ex) #&gt; [1] &quot;expression&quot; eval(ex) print(x) #&gt; [1] 1 3 5 7 9 tex &lt;- c(&#39;z&lt;-seq(1, 10, 2)&#39;, &#39;print(z)&#39; ) eval(parse(text = tex)) #&gt; [1] 1 3 5 7 9 环境变量 ls() #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;city&quot; &quot;data&quot; &quot;data_list&quot; #&gt; [6] &quot;ex&quot; &quot;group1&quot; &quot;group2&quot; &quot;left&quot; &quot;my_formula&quot; #&gt; [11] &quot;my_mat&quot; &quot;my_matrix&quot; &quot;n&quot; &quot;output&quot; &quot;right&quot; #&gt; [16] &quot;temp&quot; &quot;tex&quot; &quot;textcon&quot; &quot;vec&quot; &quot;vec_random1&quot; #&gt; [21] &quot;vec_random2&quot; &quot;vector&quot; &quot;vector1&quot; &quot;vector2&quot; &quot;vector3&quot; #&gt; [26] &quot;x&quot; &quot;xvar&quot; &quot;z&quot; env1 &lt;- new.env() assign(&quot;x1&quot;, 1:5, envir = env1) ls(envir = env1) #&gt; [1] &quot;x1&quot; get(&#39;x1&#39;, envir = env1) # 为啥没法直接用 x1 取呢？ #&gt; [1] 1 2 3 4 5 exists(&#39;x1&#39;, envir = env1) #&gt; [1] TRUE rm(&#39;x1&#39;, envir = env1) 函数 exp(1) #&gt; [1] 2.72 myfunc &lt;- function(r){ area &lt;- pi*r^2 return(area) } # 内部可以调用 global value print(myfunc(4)) #&gt; [1] 50.3 myfunc #&gt; function(r){ #&gt; area &lt;- pi*r^2 #&gt; return(area) #&gt; } "],
["section-2.html", "2 数据读取与输出 2.1 读取 read.table 2.2 高阶包 readr", " 2 数据读取与输出 2.1 读取 read.table 读取普通数据可用 read.table，有6个参数比较重要： file：文件路径 sep：文件的分隔符，缺省无 skip：跳过开始的 skip 行开始读取 header：是否将第一行读取为列名，缺省 FALSE nrows：读取的行数 fill：将缺失数据定为 NA, 缺省并无指定 2.2 高阶包 readr 也可用 readr 包读取表格型数据，不仅速度快，且能直接读取为 tbl 格式。参考 readr 介绍。 library(readr) read_csv 和 read_tsv 分别读取分隔符为逗号和制表符的数据，read_csv2 则是读取分号分割的数据，read_dlim 读取自定义的。 函数定义： # read_delim(file, delim, quote = &quot;\\&quot;&quot;, escape_backslash = FALSE, # escape_double = TRUE, col_names = TRUE, col_types = NULL, # locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), comment = &quot;&quot;, skip = 0, # n_max = -1, progress = interactive()) write_csv 用于写入数据，不写入行名。 函数定义 # write_csv(x, path, na = &quot;NA&quot;, append = FALSE, col_names = !append) "],
["apply-.html", "3 apply 家族 3.1 循环迭代之 lapply/sapply 3.2 分组运算 3.3 多参数运算", " 3 apply 家族 参考1：掌握R语言中的apply函数族 参考2：R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate 参考3：R语言apply家族函数的用法及其比较 3.1 循环迭代之 lapply/sapply sapply，lapply 的简化版 第一参数是 X，官方解释说，可接收向量，list，或表达式对象，其他对象将被强制按 list，第二个参数则是函数，返回一个向量或矩阵。 func &lt;- function(x){ if (x %% 2 == 0){ ret &lt;- &#39;even&#39; } else { ret &lt;- &#39;odd&#39; } return(ret) } vec &lt;- round(runif(4)*100) func(vec) #&gt; Warning in if (x%%2 == 0) {: the condition has length &gt; 1 and only the #&gt; first element will be used #&gt; [1] &quot;even&quot; vec #&gt; [1] 8 83 60 16 sapply(vec, func) #&gt; [1] &quot;even&quot; &quot;odd&quot; &quot;even&quot; &quot;even&quot; lapply 跟 sapply 的区别在于返回的是列表 lapply(vec, func) #&gt; [[1]] #&gt; [1] &quot;even&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;odd&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;even&quot; #&gt; #&gt; [[4]] #&gt; [1] &quot;even&quot; mylist &lt;- as.list(iris[, 1:4]) # 不转list，也是强按 yourdata &lt;- iris[, 1:4] sapply(mylist, mean) # 还可以对列表进行计算 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width #&gt; 5.84 3.06 3.76 1.20 lapply(mylist, mean) # return a list #&gt; $Sepal.Length #&gt; [1] 5.84 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.06 #&gt; #&gt; $Petal.Length #&gt; [1] 3.76 #&gt; #&gt; $Petal.Width #&gt; [1] 1.2 myfunc &lt;- function(x) { ret &lt;- c(mean(x),sd(x)) return(ret) } result &lt;- lapply(mylist, myfunc) result #&gt; $Sepal.Length #&gt; [1] 5.843 0.828 #&gt; #&gt; $Sepal.Width #&gt; [1] 3.057 0.436 #&gt; #&gt; $Petal.Length #&gt; [1] 3.76 1.77 #&gt; #&gt; $Petal.Width #&gt; [1] 1.199 0.762 t(sapply(result, &#39;[&#39;)) # list数据转 data.frame #&gt; [,1] [,2] #&gt; Sepal.Length 5.84 0.828 #&gt; Sepal.Width 3.06 0.436 #&gt; Petal.Length 3.76 1.765 #&gt; Petal.Width 1.20 0.762 3.2 分组运算 apply 第一个参数接收数组或矩阵，MARGIN 参数按行或列计算 set.seed(1) vec &lt;- round(runif(12)*100) mat &lt;- matrix(vec, nrow = 3, ncol = 4) apply(mat, MARGIN = 1, sum) # 1为行，2为列 #&gt; [1] 218 144 228 tapply tapply用于分组的循环计算，通过INDEX参数可以把数据集X进行分组，相当于group by的操作。 head(iris) #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3.0 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5.0 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa with(iris, tapply(Sepal.Length, list(Species), mean)) #&gt; setosa versicolor virginica #&gt; 5.01 5.94 6.59 aggregate 比较友好，返回的是数据框 aggregate(iris$Sepal.Length, list(iris$Species), mean) #&gt; Group.1 x #&gt; 1 setosa 5.01 #&gt; 2 versicolor 5.94 #&gt; 3 virginica 6.59 3.3 多参数运算 mapply 这个函数目前理解的还不是很透彻，待补。 mapply(rep, times = 1:4, x = 4:1) #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] 3 3 #&gt; #&gt; [[3]] #&gt; [1] 2 2 2 #&gt; #&gt; [[4]] #&gt; [1] 1 1 1 1 "],
["dplyr.html", "4 dplyr 4.1 导入数据 4.2 数据筛选 filter，返回满足条件的观测值 4.3 子集选取 select，只保留选择的变量 4.4 数据排序 arrange 4.5 数据扩展 mutate 4.6 数据汇总 summarise 4.7 数据连接 join 4.8 分组汇总 group_by", " 4 dplyr 4.1 导入数据 # 用 readr 包把数据读取成 tbl 格式，省去转化的那一步。 library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union library(readr) order &lt;- read_csv(&#39;~/Nutstore/R/dplyr/dplyr-data/order.csv&#39;)[-1] # 去除空名的第一列 #&gt; Warning: Missing column names filled in: &#39;X1&#39; [1] #&gt; Parsed with column specification: #&gt; cols( #&gt; X1 = col_integer(), #&gt; orderid = col_integer(), #&gt; customerid = col_integer(), #&gt; campaignid = col_integer(), #&gt; orderdate = col_date(format = &quot;&quot;), #&gt; city = col_character(), #&gt; state = col_character(), #&gt; zipcode = col_character(), #&gt; paymenttype = col_character(), #&gt; totalprice = col_double(), #&gt; numorderlines = col_integer(), #&gt; numunits = col_integer() #&gt; ) order #&gt; # A tibble: 100,000 x 11 #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002856 103122 2141 2011-06-02 MIAMI FL 33137 #&gt; 4 1002857 130980 2173 2009-10-14 E RUTHERFORD NJ 07073 #&gt; 5 1002886 48553 2141 2010-11-19 BALTIMORE MD 21218 #&gt; 6 1002887 106150 2173 2009-10-15 ROWAYTON CT 06853 #&gt; # ... with 9.999e+04 more rows, and 4 more variables: paymenttype &lt;chr&gt;, #&gt; # totalprice &lt;dbl&gt;, numorderlines &lt;int&gt;, numunits &lt;int&gt; 4.2 数据筛选 filter，返回满足条件的观测值 # 看 2009-10-15 日的数据 filter(order, orderdate == &#39;2009-10-13&#39;) #&gt; # A tibble: 19 x 11 #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002442 112970 2173 2009-10-13 BRANFORD CT 06405 #&gt; 4 1002471 125377 2173 2009-10-13 VALLEY FORGE PA 19482 #&gt; 5 1002472 133164 2173 2009-10-13 FORT WORTH TX 76107 #&gt; 6 1003224 129708 2173 2009-10-13 CERRO GORDO NC 28430 #&gt; # ... with 13 more rows, and 4 more variables: paymenttype &lt;chr&gt;, #&gt; # totalprice &lt;dbl&gt;, numorderlines &lt;int&gt;, numunits &lt;int&gt; # 更细的筛选 filter(order, orderdate == &#39;2009-10-13&#39; &amp; totalprice &gt; 100) -&gt; new_tbl new_tbl #&gt; # A tibble: 1 x 11 #&gt; orderid customerid campaignid orderdate city state zipcode #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; # ... with 4 more variables: paymenttype &lt;chr&gt;, totalprice &lt;dbl&gt;, #&gt; # numorderlines &lt;int&gt;, numunits &lt;int&gt; 4.3 子集选取 select，只保留选择的变量 # 选取几个子集 names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; select(order, city, numunits, zipcode) #&gt; # A tibble: 100,000 x 3 #&gt; city numunits zipcode #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 NEWTON 3 02459 #&gt; 2 NEW ROCHELLE 1 10804 #&gt; 3 MIAMI 2 33137 #&gt; 4 E RUTHERFORD 1 07073 #&gt; 5 BALTIMORE 1 21218 #&gt; 6 ROWAYTON 1 06853 #&gt; # ... with 9.999e+04 more rows # 换名, 提取选择的数据列 select(order, date = orderdate, price = totalprice) #&gt; # A tibble: 100,000 x 2 #&gt; date price #&gt; &lt;date&gt; &lt;dbl&gt; #&gt; 1 2009-10-13 190.0 #&gt; 2 2009-10-13 10.0 #&gt; 3 2011-06-02 35.2 #&gt; 4 2009-10-14 10.0 #&gt; 5 2010-11-19 10.0 #&gt; 6 2009-10-15 10.0 #&gt; # ... with 9.999e+04 more rows names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; # rename,换名，提取所有列 rename(order, date = orderdate, price = totalprice) #&gt; # A tibble: 100,000 x 11 #&gt; orderid customerid campaignid date city state zipcode #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1002854 45978 2141 2009-10-13 NEWTON MA 02459 #&gt; 2 1002855 125381 2173 2009-10-13 NEW ROCHELLE NY 10804 #&gt; 3 1002856 103122 2141 2011-06-02 MIAMI FL 33137 #&gt; 4 1002857 130980 2173 2009-10-14 E RUTHERFORD NJ 07073 #&gt; 5 1002886 48553 2141 2010-11-19 BALTIMORE MD 21218 #&gt; 6 1002887 106150 2173 2009-10-15 ROWAYTON CT 06853 #&gt; # ... with 9.999e+04 more rows, and 4 more variables: paymenttype &lt;chr&gt;, #&gt; # price &lt;dbl&gt;, numorderlines &lt;int&gt;, numunits &lt;int&gt; names(order) #&gt; [1] &quot;orderid&quot; &quot;customerid&quot; &quot;campaignid&quot; &quot;orderdate&quot; #&gt; [5] &quot;city&quot; &quot;state&quot; &quot;zipcode&quot; &quot;paymenttype&quot; #&gt; [9] &quot;totalprice&quot; &quot;numorderlines&quot; &quot;numunits&quot; # 选取以 order 开始的变量 select(order, starts_with(&#39;order&#39;)) #&gt; # A tibble: 100,000 x 2 #&gt; orderid orderdate #&gt; &lt;int&gt; &lt;date&gt; #&gt; 1 1002854 2009-10-13 #&gt; 2 1002855 2009-10-13 #&gt; 3 1002856 2011-06-02 #&gt; 4 1002857 2009-10-14 #&gt; 5 1002886 2010-11-19 #&gt; 6 1002887 2009-10-15 #&gt; # ... with 9.999e+04 more rows # 选取包含id 的变量 select(order, contains(&#39;id&#39;)) #&gt; # A tibble: 100,000 x 3 #&gt; orderid customerid campaignid #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1002854 45978 2141 #&gt; 2 1002855 125381 2173 #&gt; 3 1002856 103122 2141 #&gt; 4 1002857 130980 2173 #&gt; 5 1002886 48553 2141 #&gt; 6 1002887 106150 2173 #&gt; # ... with 9.999e+04 more rows 4.4 数据排序 arrange tbl &lt;- select(order, date = orderdate, price = totalprice) arrange(tbl, date, desc(price)) #&gt; # A tibble: 100,000 x 2 #&gt; date price #&gt; &lt;date&gt; &lt;dbl&gt; #&gt; 1 2009-10-04 200 #&gt; 2 2009-10-04 120 #&gt; 3 2009-10-04 100 #&gt; 4 2009-10-04 100 #&gt; 5 2009-10-04 70 #&gt; 6 2009-10-04 50 #&gt; # ... with 9.999e+04 more rows # 管道操作，更简便 tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% arrange(date, desc(price)) tbl #&gt; # A tibble: 100,000 x 2 #&gt; date price #&gt; &lt;date&gt; &lt;dbl&gt; #&gt; 1 2009-10-04 200 #&gt; 2 2009-10-04 120 #&gt; 3 2009-10-04 100 #&gt; 4 2009-10-04 100 #&gt; 5 2009-10-04 70 #&gt; 6 2009-10-04 50 #&gt; # ... with 9.999e+04 more rows 4.5 数据扩展 mutate tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% arrange(date,desc(price)) %&gt;% mutate(year = substr(date,1,4), month = substr(date,6,7), day = substr(date,9,10)) tbl #&gt; # A tibble: 100,000 x 5 #&gt; date price year month day #&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2009-10-04 200 2009 10 04 #&gt; 2 2009-10-04 120 2009 10 04 #&gt; 3 2009-10-04 100 2009 10 04 #&gt; 4 2009-10-04 100 2009 10 04 #&gt; 5 2009-10-04 70 2009 10 04 #&gt; 6 2009-10-04 50 2009 10 04 #&gt; # ... with 9.999e+04 more rows # transmute 则会删除原有的变量，如同 select 与 rename 4.6 数据汇总 summarise summarise(tbl, max = max(price), min = min(price), mean(price)) #&gt; # A tibble: 1 x 3 #&gt; max min mean(price) #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 6780 0 60.8 summarise(tbl, fisrt = first(date), last = last(date)) #&gt; # A tibble: 1 x 2 #&gt; fisrt last #&gt; &lt;date&gt; &lt;date&gt; #&gt; 1 2009-10-04 2014-05-29 # 管道操作 df &lt;- select(order, date = orderdate, price = totalprice) %&gt;% summarise(price_sum = sum(price), price_mean = mean(price)) df #&gt; # A tibble: 1 x 2 #&gt; price_sum price_mean #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 6077773 60.8 4.7 数据连接 join left_join 以左边为主，且保留所有值，用的最多，b 表追加在后面 inner_join 只保留匹配的 semi_join 只匹配左边的列 anti_join 与上面函数相反 4.8 分组汇总 group_by tbl &lt;- select(order, date = orderdate, price = totalprice) %&gt;% mutate(year = substr(date,1,4), month = substr(date,6,7), day = substr(date,9,10)) by_year &lt;- group_by(tbl, year) %&gt;% summarise(mean(price), sum(price), max(month)) by_year #&gt; # A tibble: 6 x 4 #&gt; year mean(price) sum(price) max(month) #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2009 34.1 262628 12 #&gt; 2 2010 52.2 967429 12 #&gt; 3 2011 51.4 1380637 12 #&gt; 4 2012 68.4 1404113 12 #&gt; 5 2013 76.7 1633005 12 #&gt; 6 2014 84.5 429962 05 order_year &lt;- group_by(tbl, year) "]
]
